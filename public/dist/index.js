/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ChatUIHandler.ts":
/*!******************************!*\
  !*** ./src/ChatUIHandler.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst WebSocketHandler_1 = __importDefault(__webpack_require__(/*! ./WebSocketHandler */ \"./src/WebSocketHandler.ts\"));\nconst PeerConnectionHandler_1 = __importDefault(__webpack_require__(/*! ./PeerConnectionHandler */ \"./src/PeerConnectionHandler.ts\"));\nclass ChatUIHandler {\n    /**\n     * Initializes a new ChatUIHandler.\n     *\n     * @param {ChatUIElements} elements - The DOM elements.\n     */\n    constructor(elements) {\n        this.localStream = null;\n        this.username = \"You\";\n        this.localVideo = elements.localVideo;\n        this.remoteVideo = elements.remoteVideo;\n        this.startButton = elements.startButton;\n        this.setUsernameButton = elements.setUsernameButton;\n        this.endButton = elements.endButton;\n        this.muteButton = elements.muteButton;\n        this.unmuteButton = elements.unmuteButton;\n        this.sendButton = elements.sendButton;\n        this.fileInput = elements.fileInput;\n        this.sendFileButton = elements.sendFileButton;\n        this.chatInput = elements.chatInput;\n        this.chatBox = elements.chatBox;\n        this.usernameInput = elements.usernameInput;\n        this.localUsernameLabel = elements.localUsernameLabel;\n        this.remoteUsernameLabel = elements.remoteUsernameLabel;\n        this.peerConnectionHandler = new PeerConnectionHandler_1.default(this.remoteVideo);\n        this.webSocketHandler = new WebSocketHandler_1.default(\"ws://localhost:3000\");\n        this.init();\n    }\n    /**\n     * Initializes UI event listeners and WebSocket handlers.\n     */\n    init() {\n        this.webSocketHandler.on(\"open\", this.handleWebSocketOpen.bind(this));\n        this.webSocketHandler.on(\"error\", this.handleWebSocketError.bind(this));\n        this.webSocketHandler.on(\"close\", this.handleWebSocketClose.bind(this));\n        this.webSocketHandler.on(\"message\", this.handleWebSocketMessage.bind(this));\n        this.setUsernameButton.addEventListener(\"click\", this.setUsername.bind(this));\n        this.startButton.addEventListener(\"click\", this.startVideoChat.bind(this));\n        this.endButton.addEventListener(\"click\", this.endVideoChat.bind(this));\n        this.muteButton.addEventListener(\"click\", () => this.toggleMic(false));\n        this.unmuteButton.addEventListener(\"click\", () => this.toggleMic(true));\n        this.sendButton.addEventListener(\"click\", this.sendMessage.bind(this));\n        this.sendFileButton.addEventListener(\"click\", () => this.fileInput.click());\n        this.fileInput.addEventListener(\"change\", this.handleFileInput.bind(this));\n        this.chatInput.addEventListener(\"keypress\", (event) => {\n            if (event.key === \"Enter\") {\n                event.preventDefault();\n                this.sendMessage();\n            }\n        });\n        this.peerConnectionHandler.onIceCandidate = (candidate) => {\n            this.webSocketHandler.send({\n                type: \"candidate\",\n                candidate,\n                username: this.username,\n            });\n        };\n    }\n    /**\n     * Handles WebSocket connection open event.\n     */\n    handleWebSocketOpen() {\n        console.log(\"WebSocket connection established\");\n    }\n    /**\n     * Handles WebSocket error event.\n     *\n     * @param {Event} error - The error event.\n     */\n    handleWebSocketError(error) {\n        console.error(\"WebSocket error:\", error);\n    }\n    /**\n     * Handles WebSocket close event.\n     */\n    handleWebSocketClose() {\n        console.log(\"WebSocket connection closed\");\n    }\n    /**\n     * Handles incoming WebSocket messages.\n     *\n     * @param {MessageEvent} event - The message event.\n     */\n    handleWebSocketMessage(event) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const message = JSON.parse(event.data);\n            console.log(\"Received WebSocket message:\", message);\n            switch (message.type) {\n                case \"offer\":\n                    yield this.handleOffer(message);\n                    break;\n                case \"answer\":\n                    yield this.handleAnswer(message);\n                    break;\n                case \"candidate\":\n                    yield this.handleCandidate(message);\n                    break;\n                case \"chat\":\n                    this.displayChatMessage(message);\n                    break;\n                case \"file\":\n                    this.displayFileMessage(message);\n                    break;\n                case \"end\":\n                    this.handleEndChat();\n                    break;\n            }\n        });\n    }\n    /**\n     * Sets the username for the local user.\n     */\n    setUsername() {\n        this.username = this.usernameInput.value || \"Anonymous\";\n        this.localUsernameLabel.textContent = this.username;\n        console.log(\"Username set to:\", this.username);\n    }\n    /**\n     * Starts the video chat by obtaining user media and creating an offer.\n     */\n    startVideoChat() {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(\"Start button clicked\");\n            try {\n                this.localStream = yield navigator.mediaDevices.getUserMedia({\n                    video: true,\n                    audio: true,\n                });\n                console.log(\"User media obtained\");\n                this.localVideo.srcObject = this.localStream;\n                this.peerConnectionHandler.addStream(this.localStream);\n                const offer = yield this.peerConnectionHandler.createOffer();\n                this.webSocketHandler.send({ type: \"offer\", offer, username: this.username });\n                this.updateUIForChatStart();\n            }\n            catch (e) {\n                console.error(\"Error accessing media devices.\", e);\n            }\n        });\n    }\n    /**\n     * Ends the video chat by sending an end message and resetting the UI.\n     */\n    endVideoChat() {\n        console.log(\"End button clicked\");\n        this.webSocketHandler.send({ type: \"end\" });\n        this.handleEndChat();\n    }\n    /**\n     * Handles file input change event to send the selected file.\n     *\n     * @param {Event} event - The change event.\n     */\n    handleFileInput(event) {\n        var _a;\n        const target = event.target;\n        const file = (_a = target.files) === null || _a === void 0 ? void 0 : _a[0];\n        if (file) {\n            const reader = new FileReader();\n            reader.onload = (e) => {\n                var _a;\n                const fileData = (_a = e.target) === null || _a === void 0 ? void 0 : _a.result;\n                const fileMessage = {\n                    type: \"file\",\n                    file: fileData,\n                    filename: file.name,\n                    username: this.username,\n                };\n                this.webSocketHandler.send(fileMessage);\n                this.displayFileMessage(fileMessage, true);\n            };\n            reader.readAsDataURL(file);\n        }\n    }\n    /**\n     * Sends a chat message to the server.\n     */\n    sendMessage() {\n        const message = this.chatInput.value.trim();\n        if (message) {\n            const chatMessage = { type: \"chat\", message, username: this.username };\n            this.webSocketHandler.send(chatMessage);\n            this.displayChatMessage(chatMessage, true);\n            this.chatInput.value = \"\";\n        }\n    }\n    /**\n     * Handles WebRTC offer messages.\n     *\n     * @param {any} message - The offer message.\n     */\n    handleOffer(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.peerConnectionHandler.setRemoteDescription(message.offer);\n            const answer = yield this.peerConnectionHandler.createAnswer();\n            this.webSocketHandler.send({ type: \"answer\", answer, username: this.username });\n            this.remoteUsernameLabel.textContent = message.username;\n        });\n    }\n    /**\n     * Handles WebRTC answer messages.\n     *\n     * @param {any} message - The answer message.\n     */\n    handleAnswer(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.peerConnectionHandler.setRemoteDescription(message.answer);\n            this.remoteUsernameLabel.textContent = message.username;\n        });\n    }\n    /**\n     * Handles WebRTC ICE candidate messages.\n     *\n     * @param {any} message - The ICE candidate message.\n     */\n    handleCandidate(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.peerConnectionHandler.addIceCandidate(message.candidate);\n        });\n    }\n    /**\n     * Displays a chat message in the chat box.\n     *\n     * @param {any} data - The chat message data.\n     * @param {boolean} [isSent=false] - Whether the message was sent by the local user.\n     */\n    displayChatMessage(data, isSent = false) {\n        const messageElement = document.createElement(\"div\");\n        messageElement.classList.add(\"message\", isSent ? \"sent\" : \"received\");\n        const contentElement = document.createElement(\"div\");\n        contentElement.classList.add(\"content\");\n        contentElement.textContent = isSent\n            ? data.message\n            : `${data.username}: ${data.message}`;\n        messageElement.appendChild(contentElement);\n        this.chatBox.appendChild(messageElement);\n        this.chatBox.scrollTop = this.chatBox.scrollHeight;\n    }\n    /**\n     * Displays a file message in the chat box.\n     *\n     * @param {any} data - The file message data.\n     * @param {boolean} [isSent=false] - Whether the message was sent by the local user.\n     */\n    displayFileMessage(data, isSent = false) {\n        const messageElement = document.createElement(\"div\");\n        messageElement.classList.add(\"message\", isSent ? \"sent\" : \"received\");\n        const contentElement = document.createElement(\"div\");\n        contentElement.classList.add(\"content\");\n        const img = document.createElement(\"img\");\n        img.src = data.file;\n        img.alt = data.filename;\n        img.style.maxWidth = \"100%\";\n        img.style.borderRadius = \"5px\";\n        contentElement.appendChild(img);\n        messageElement.appendChild(contentElement);\n        this.chatBox.appendChild(messageElement);\n        this.chatBox.scrollTop = this.chatBox.scrollHeight; // Auto-scroll to the latest message\n    }\n    /**\n     * Handles ending the chat by closing the peer connection and resetting the UI.\n     */\n    handleEndChat() {\n        this.peerConnectionHandler.close();\n        if (this.localStream) {\n            this.localStream.getTracks().forEach((track) => track.stop());\n            this.localStream = null;\n        }\n        this.localVideo.srcObject = null;\n        this.remoteVideo.srcObject = null;\n        this.resetUI();\n        console.log(\"Chat ended\");\n    }\n    /**\n     * Toggles the microphone on or off.\n     *\n     * @param {boolean} unmute - Whether to unmute the microphone.\n     */\n    toggleMic(unmute) {\n        if (this.localStream) {\n            this.localStream.getAudioTracks()[0].enabled = unmute;\n            this.muteButton.style.display = unmute ? \"inline\" : \"none\";\n            this.unmuteButton.style.display = unmute ? \"none\" : \"inline\";\n        }\n    }\n    /**\n     * Updates the UI to show chat controls when a chat starts.\n     */\n    updateUIForChatStart() {\n        this.endButton.style.display = \"inline\";\n        this.muteButton.style.display = \"inline\";\n        this.sendFileButton.style.display = \"inline\";\n    }\n    /**\n     * Resets the UI to its initial state.\n     */\n    resetUI() {\n        this.remoteUsernameLabel.textContent = \"Remote User\";\n        this.chatBox.innerHTML = \"\";\n        this.endButton.style.display = \"none\";\n        this.muteButton.style.display = \"none\";\n        this.unmuteButton.style.display = \"none\";\n        this.sendFileButton.style.display = \"none\";\n    }\n}\nexports[\"default\"] = ChatUIHandler;\n\n\n//# sourceURL=webpack://backend/./src/ChatUIHandler.ts?");

/***/ }),

/***/ "./src/PeerConnectionHandler.ts":
/*!**************************************!*\
  !*** ./src/PeerConnectionHandler.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass PeerConnectionHandler {\n    /**\n     * Initializes a new PeerConnectionHandler.\n     *\n     * @param {HTMLVideoElement} remoteVideo - The remote video element.\n     */\n    constructor(remoteVideo) {\n        this.peerConnection = new RTCPeerConnection();\n        this.remoteVideo = remoteVideo;\n        this.init();\n    }\n    /**\n     * Initializes the RTCPeerConnection event listeners.\n     * These event listeners are fundamental for WebRTC connection establishment\n     * and media handling\n     */\n    init() {\n        // Handles ICE candidate generation for establishing peer-to-peer connection\n        this.peerConnection.onicecandidate = (event) => {\n            // When a new ICE candidate is available, it triggers the onIceCandidate\n            // callback for signaling\n            if (event.candidate) {\n                this.onIceCandidate(event.candidate);\n            }\n        };\n        // Manages incoming media streams from the remote peer\n        this.peerConnection.ontrack = (event) => {\n            if (this.remoteVideo.srcObject !== event.streams[0]) {\n                // When a new track is received, it assigns the stream to the remote\n                // video element, enabling the display of the remote peer's video\n                this.remoteVideo.srcObject = event.streams[0];\n            }\n        };\n    }\n    /**\n     * Handler for ICE candidate events. Should be overridden.\n     *\n     * @param {RTCIceCandidate} candidate - The ICE candidate.\n     */\n    onIceCandidate(candidate) { }\n    /**\n     * Adds a media stream to the peer connection.\n     *\n     * @param {MediaStream} stream - The media stream to add.\n     */\n    addStream(stream) {\n        stream.getTracks().forEach((track) => this.peerConnection.addTrack(track, stream));\n    }\n    /**\n     * Creates an offer for the peer connection.\n     *\n     * @returns {Promise<RTCSessionDescriptionInit>} The created offer.\n     */\n    createOffer() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const offer = yield this.peerConnection.createOffer();\n            yield this.peerConnection.setLocalDescription(offer);\n            return offer;\n        });\n    }\n    /**\n     * Creates an answer for the peer connection.\n     *\n     * @returns {Promise<RTCSessionDescriptionInit>} The created answer.\n     */\n    createAnswer() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const answer = yield this.peerConnection.createAnswer();\n            yield this.peerConnection.setLocalDescription(answer);\n            return answer;\n        });\n    }\n    /**\n     * Sets the remote description for the peer connection.\n     *\n     * @param {RTCSessionDescriptionInit} description - The remote description.\n     */\n    setRemoteDescription(description) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.peerConnection.setRemoteDescription(new RTCSessionDescription(description));\n        });\n    }\n    /**\n     * Adds an ICE candidate to the peer connection.\n     *\n     * @param {RTCIceCandidateInit} candidate - The ICE candidate.\n     */\n    addIceCandidate(candidate) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n        });\n    }\n    /**\n     * Closes the peer connection.\n     */\n    close() {\n        this.peerConnection.close();\n    }\n}\nexports[\"default\"] = PeerConnectionHandler;\n\n\n//# sourceURL=webpack://backend/./src/PeerConnectionHandler.ts?");

/***/ }),

/***/ "./src/WebSocketHandler.ts":
/*!*********************************!*\
  !*** ./src/WebSocketHandler.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass WebSocketHandler {\n    /**\n     * Initializes a new WebSocketHandler.\n     *\n     * @param {string} url - The WebSocket server URL.\n     */\n    constructor(url) {\n        this.handlers = {};\n        this.ws = new WebSocket(url);\n        this.init();\n    }\n    /**\n     * Initializes WebSocket event listeners.\n     */\n    init() {\n        this.ws.addEventListener(\"open\", (e) => this.handleEvent(\"open\", e));\n        this.ws.addEventListener(\"error\", (e) => this.handleEvent(\"error\", e));\n        this.ws.addEventListener(\"close\", (e) => this.handleEvent(\"close\", e));\n        this.ws.addEventListener(\"message\", (e) => this.handleEvent(\"message\", e));\n    }\n    /**\n     * Handles WebSocket events by invoking the corresponding handlers.\n     *\n     * @param {string} event - The event type.\n     * @param {Event} e - The event object.\n     */\n    handleEvent(event, e) {\n        if (this.handlers[event]) {\n            this.handlers[event].forEach((handler) => handler(e));\n        }\n    }\n    /**\n     * Adds a handler for a specific WebSocket event.\n     *\n     * @param {string} event - The event type.\n     * @param {Function} handler - The handler function.\n     */\n    on(event, handler) {\n        if (!this.handlers[event]) {\n            this.handlers[event] = [];\n        }\n        this.handlers[event].push(handler);\n    }\n    /**\n     * Sends data to the WebSocket server.\n     *\n     * @param {any} data - The data to send.\n     */\n    send(data) {\n        this.ws.send(JSON.stringify(data));\n    }\n}\nexports[\"default\"] = WebSocketHandler;\n\n\n//# sourceURL=webpack://backend/./src/WebSocketHandler.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ChatUIHandler_1 = __importDefault(__webpack_require__(/*! ./ChatUIHandler */ \"./src/ChatUIHandler.ts\"));\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    const elements = {\n        localVideo: document.getElementById(\"localVideo\"),\n        remoteVideo: document.getElementById(\"remoteVideo\"),\n        startButton: document.getElementById(\"startButton\"),\n        setUsernameButton: document.getElementById(\"setUsernameButton\"),\n        endButton: document.getElementById(\"endButton\"),\n        muteButton: document.getElementById(\"muteButton\"),\n        unmuteButton: document.getElementById(\"unmuteButton\"),\n        sendButton: document.getElementById(\"sendButton\"),\n        fileInput: document.getElementById(\"fileInput\"),\n        sendFileButton: document.getElementById(\"sendFileButton\"),\n        chatInput: document.getElementById(\"chatInput\"),\n        chatBox: document.getElementById(\"chatBox\"),\n        usernameInput: document.getElementById(\"username\"),\n        localUsernameLabel: document.getElementById(\"localUsernameLabel\"),\n        remoteUsernameLabel: document.getElementById(\"remoteUsernameLabel\"),\n    };\n    new ChatUIHandler_1.default(elements);\n});\n\n\n//# sourceURL=webpack://backend/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;